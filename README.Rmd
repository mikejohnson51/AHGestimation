---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)

library(dplyr)
library(ggplot2)
library(patchwork)
```

<!-- badges: start -->
[![R CMD Check](https://github.com/mikejohnson51/FHGestimation/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/mikejohnson51/FHGestimation/actions/workflows/R-CMD-check.yaml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://choosealicense.com/licenses/mit/)
[![Project Status: Active](https://www.repostatus.org/badges/latest/active.svg)](https://www.repostatus.org/#active)
[![codecov](https://codecov.io/github/mikejohnson51/FHGestimation/graph/badge.svg?token=YIY3BTM32H)](https://codecov.io/github/mikejohnson51/FHGestimation)
[![Dependencies](https://img.shields.io/badge/dependencies-4/42-green?style=flat)](#)
<!-- badges: end -->

# FHGestimation

> **_Citation:_** Johnson, J.M. (2022) FHGestimation^[previously AHGestimation]: Tools for Estimating Physically-Based, Computationally Efficient Feature Based Hydraulic
Geometry and Rating Curves.

Using data from the USGS manual measurement (Johnson, 2018), we can illustrate the utilities in this package. Overall this package provides 4 capabilities:

1. Single Relation fits
2. Full hydraulic system fits
3. Data preprocessing
4. Derivation of cross sections and additional hydraulic traits 

## Base data

```{r}
library(FHGestimation)
data = nwis
```

```{r, echo = F}
ggplot(data = data ) + 
  geom_point(aes(x = Q, y = Y)) + 
  theme_light()  + 
  labs(title = 'Q-Y Relationship') +
ggplot(data = data ) + 
  geom_point(aes(x = Q, y = TW)) + 
  theme_light() + 
  labs(title = 'Q-TW Relationship') + 
ggplot(data = data ) + 
  geom_point(aes(x = Q, y = V)) + 
  theme_light()  + 
  labs(title = 'Q-V Relationship')
```

## Single Relationship fits

Here we use the `FHGestimation` package to fit the Q-Y relationship using OLS and NLS models:

```{r}
(sf = fhg_estimate(df = select(data, Q, Y), allowance = .05))
```

```{r, echo = FALSE}
ggplot() + 
  geom_point(data = data, aes(x = Q, y = Y), col = "black") + 
  geom_line(data = data, aes(x = Q, y = sf$coef[1] * Q ^ (sf$exp[1]), col = "NLS")) +
  geom_line(data = data, aes(x = Q, y = sf$coef[2] * Q ^ (sf$exp[2]), col = "OLS")) +
  theme_light()  +
  theme(legend.position = "bottom") +
  labs(title = 'Q-Y Relationship', color = "Fit") + 
  scale_color_manual(values = c( "NLS" = "blue", "OLS" = "red"))

```

Overall the the NLS model provides a better fit (albeit small) when measured both by nRMSE and pBais.

## Full Hydraulic fits

When we have data regarding three hydraulic states (V,TW,Y) we can ensure that the solutions found are physically valid (meets the continuity constraint Q = Y x V x TW).

In this mode the OLS and NLS models are fit, and if continuity is not met, then a Evolutionary Approach is implemented. Doing so produces three unique fits for three variables (27 total combinations). These are crossed to identify the best performing relationships that meet continuity at a prescribed allowance:

```{r}
(x = fhg_estimate(data, allowance = .05))
```
Overall an combination of the OLS and NLS fit are able to provide a error minimizing solution:

```{r, echo = F}
ggplot() + 
  geom_point(data = data, aes(x = Q, y = Y), col = "black") + 
  geom_line(data = data, aes(x = Q, y = x$Y_coef[1] * Q ^ (x$Y_exp[1]), col = "bestValid")) +
  theme_light()  + 
  labs(title = 'Q-Y Relationship', color = "Fit") + 
ggplot(data = data ) + 
  geom_point(data = data, aes(x = Q, y = Y), col = "black") + 
  geom_line(data = data, aes(x = Q, y = x$Y_coef[1] * Q ^ (x$Y_exp[1]), col = "bestValid")) +
  theme_light() + 
  labs(title = 'Q-TW Relationship', color = "Fit") + 
ggplot(data = data ) + 
  geom_point(data = data, aes(x = Q, y = V), col = "black") + 
  geom_line(data = data, aes(x = Q, y = x$V_coef[1] * Q ^ (x$V_exp[1]), col = "bestValid")) +
  theme_light()  + 
  labs(title = 'Q-V Relationship', color = "Fit") + 
  plot_layout(guides = "collect") & 
  theme(legend.position = 'bottom')
```

In the above example we see that NLS was able to provide better fits the OLS but neither  NLS or OLS was able to provide physically valid solutions (viable). While the nsga2 approach was able to provide a physically valid solution, its error was almost 10% higher then the OLS/NLS methods.

However a combined approach of a NLS, OLS, and nsga2 was able to provide a physically valid result with only 0.03% more error the seen in the best performing NLS method.

** This was all done using raw, unrefined data! **

## Data Filtering

Due to the volatility of river systems and deviations in measurement techniques and accuracy hydraulic data is often very noisy. While the `fhg_estimation` tool is intended to reduce this noise and produce a mass-conserving hydraulic fit, it is also possible to filter the data prior to fitting. The range of data filtering options provided are documented in the data-filtering vignette and an example is provided below:

```{r}
(xf = data %>% 
  # Keep the most recent 10 year
  date_filter(year = 10, keep_max = TRUE) %>% 
  # Keep data within 3 Median absolute deviations (log residuals)
  mad_filter() %>% 
  # Keep data that respects the Q = vA criteria w/in allowance
  qva_filter() %>% 
  fhg_estimate())
```

When the data is effectively filtered we see NLS can provide an error minimizing, valid solution for the system that is quite different then the full data fit:

```{r, echo = F}

hf_data = data %>% 
  date_filter(year = 10, keep_max = TRUE) %>% 
  mad_filter() %>% 
  qva_filter()

ggplot() +  
  geom_point(data = data, aes(x = Q, y = Y, col = "Full")) + 
  geom_line(data = data, aes(x = Q, y = x$Y_coef[1] * Q ^ (x$Y_exp[1]), col = "Full")) +
  geom_point(data = hf_data, aes(x = Q, y = Y, col = "Filter")) + 
  geom_line(data = hf_data, aes(x = Q, y = xf$Y_coef[1] * Q ^ (xf$Y_exp[1]), col = "Filter")) +
  theme_light()  + 
  labs(title = 'Q-Y Relationship') + 
  scale_color_manual(values = c("Filter" = "red", "Full" = "black")) + 
ggplot(data = data ) + 
  geom_point(data = data, aes(x = Q, y = Y, col = "Full")) + 
  geom_line(data = data, aes(x = Q, y = x$Y_coef[1] * Q ^ (x$Y_exp[1]), col = "Full")) +
  geom_point(data = hf_data, aes(x = Q, y = Y, col = "Filter")) + 
  geom_line(data = hf_data, aes(x = Q, y = xf$Y_coef[1] * Q ^ (xf$Y_exp[1]), col = "Filter")) +
  theme_light() + 
  labs(title = 'Q-TW Relationship') + 
  scale_color_manual(values = c("Filter" = "red", "Full" = "black")) + 
ggplot(data = data ) + 
  geom_point(data = data, aes(x = Q, y = V, col = "Full")) + 
  geom_line(data = data, aes(x = Q, y = x$V_coef[1] * Q ^ (x$V_exp[1]), col = "Full")) +
  geom_point(data = hf_data, aes(x = Q, y = V, col = "Filter")) + 
  geom_line(data = hf_data, aes(x = Q, y = xf$V_coef[1] * Q ^ (xf$V_exp[1]), col = "Filter")) +
  theme_light()  + 
  labs(title = 'Q-V Relationship') + 
  scale_color_manual(values = c("Filter" = "red", "Full" = "black")) + 
  plot_layout(guides = "collect") & 
  theme(legend.position = 'bottom')
```

## Hydraulic Estimation

Lastly, a range of functions have been added to extend the AHG parameters into cross section hydraulics and geometry:

```{r}
filter_data = data %>% 
  date_filter(10, keep_max = TRUE) %>% 
  nls_filter(allowance = .5) 

ahg_fit = fhg_estimate(filter_data)[1,]

(shape = compute_hydraulic_params(ahg_fit))

cs = cross_section(r = shape$r,  
                   TW = max(filter_data$TW), 
                   Ymax = max(filter_data$Y))

glimpse(cs)
```

```{r, echo = FALSE}
ggplot(data = cs) + 
  geom_point(aes(x = x, y = Y)) + 
  geom_line(aes(x = x, y = Y)) + 
  theme_light() + 
  geom_hline(yintercept = max(cs$Y), color = "darkgreen") +
  geom_hline(yintercept = 2, color = "blue", linewidth = 2) +
  geom_vline(xintercept = mean(cs$x), color = "darkgreen") + 
  labs(x = "Relative Width", y = "Depth", title = "Shape") +
ggplot(data = cs) + 
  geom_point(aes(x = A, y = Y)) + 
  geom_line(aes(x = A, y = Y)) + 
  geom_hline(yintercept = 2, color = "blue", linewidth = 2) +
  theme_light() +
  labs(Y = "Depth", x = "Cross Sectional Area", title = "Area to Depth") 
```


# History 

The development of this package began as a graduate school project between friends at UC Santa Barbara and UMass Amherst following the 2017 NOAA OWP Summer Institute and clear evidence channel shape may be a limiting factor in National Water Model Performance. It has since evolved to provide an open source utility for robust large scale data synthesis and evaluation. Funding from the National Science Foundation (Grants 1937099, 2033607) provided time to draft the [preprint here](https://www.preprints.org/manuscript/202212.0390/v1) and apply an early version of this software to the [Continental Flood Inundation Mapping (CFIM)](https://cfim.ornl.gov/data/) synthetic rating curve dataset. Funding from the National Oceanic and Atmospheric Administration's Office of Water Prediction supported the addition of data filtering and hydraulic estimation, improved documentation, and code hardening. We are grateful to all involved.

# Community guidelines 

Disclaimer: These data and software are preliminary or provisional and are subject to revision. They are being provided to meet the need for timely best science. and are made freely available.  All contributions to this project are released to the public domain.  There are two primary ways to help:

* Using the issue tracker
* Changing the code-base.

## Using the issue tracker and GitHub features

Use the issue tracker to suggest feature requests, report bugs, and ask questions.  This is also a great way to connect with the developers of the project as well as others who are interested in this solution or working in the same problem space.  Use the issue tracker to find ways to contribute. Find a bug or a feature, mention in the issue that you will take on that effort, then follow the _Changing the code-base_ guidance below.

## Changing the code-bas

We welcome relevant and well executed additions to this repository.  Generally speaking, you should fork this repository, make changes in your own fork, and then submit a pull request. All new code should have associated unit tests that validate implemented features and the presence or lack of defects. Additionally, the code should follow any stylistic and architectural guidelines prescribed by the project. In the absence of such guidelines, mimic the styles and patterns in the existing code-base.
